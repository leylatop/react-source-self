1. react 脚手架没有配置选项，因为react脚手架很纯净

2. react 17版本之后不需要引入React，只引入ReactDOM 也可以进行渲染
- ```jsx
  // 老的转化后的结果
  ReactDOM.render( /*#__PURE__*/React.createElement("h1", null, "hello"), document.getElementById('root'));
  ```

  

- ```js
  // 新的转化后的结果
  Object(n.jsx)("h1",{children:"hello"})
  ```

  

3. jsx = js + xhtml

4. jsx是react团队提供的语法糖，浏览器默认不支持jsx，需要经过babel转译成js

5. `/*#__PURE__*/` 表示这是个纯函数， 在tree-shaking时可以把无用的代码删掉

6. 函数式编程&面向对象编程
- 函数式编程的核心是数据流，里面是一个个的处理函数
- 面向对象编程里是一个个对象和实例

7. JSON.stringify参数

   ```js
   JSON.stringify({ x: [10, undefined, function(){}, Symbol('')] })
   ```

   - 第一个： 要被序列化的对象
   - 第二个：
     - 如果该参数是一个函数，被序列化的值的每个属性都会经过该函数的转换和处理；
     - 如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；
     - 如果该参数为 null 或者未提供，则对象所有的属性都会被序列化；
   - 第三个：
     - space，指定缩进用的空白字符串，用于美化输出（pretty-print）



8. 虚拟dom： js对象

```json
{
    "type": "h1",       // 元素的类型
    "key": null,        // 区分同一个父亲的不同儿子的 dom-diff
    "ref": null,        // 获取真实节点
    "props": {          // 属性 
      "children": "hello"
    },
    "_owner": null,     // 先不管
    "_store": {}        // 先不管
}
```



9. render：根据虚拟dom的描述创建真实dom并插入root容器内
10. 出于安全考虑，react17之后元素元素是不可修改的，虚拟dom对象被冻结了；但是freeze是浅冻结

```js
Object.freeze();	// 冻结
// preventExtension:false 禁止添加属性
// configurable:false  禁止删除属性
// writable: false 禁止改写属性值
// 禁止更改writable为true 禁止更改enumerable为false  禁止更改configurable为true

Object.seal();	// 密封
// preventExtension:false 禁止添加属性
// configurable:false  禁止删除属性
// 可以改写
```



- 深层冻结

```js
function deepFreeze(obj) {
    Object.freeze(obj);
    for(let key in obj) {
        if(typeof obj[key] == 'object') {
            deepFreeze(obj[key])
        }
    }
}
```



11. react更新时只会更新变化的内容；

12. 渲染流程
1. createElement 创建虚拟dom；
2. render方法将虚拟com 创建真实dom;
3. updateProps 更新props
4. 深度遍历reconcileChildren
5. 创建儿子的真实dom，并且appendChildren


14. 组件
- 内置组件： h1、p、div,type为字符串
- 自定义组件：名称必须是大写字母开头；只能有一个根元素
  - 函数组件：函数组件没有原型
  - 类组件： 类组件的父类（原型）是Component， Component的原型上有一个isReactComponent 

15. state的更新可能是异步的
- 出于性能考虑，react可能会把多个setState进行合并

16. 定义state的两种方法，两种效果一模一样
- 第一种是在构造函数内部使用this.state={}进行初始化
- 第二种是在组件内部定义属性 state={}进行初始化

17. setState是同步的还是异步的？答案：有可能是同步的也有可能是异步的，此处的同步异步概念与js的同步异步概念不一致，本质是批量执行
- react能管控的地方（事件处理函数，生命周期函数），更新就是批量的；setState并不会修改this.state，等事件结束后，再进行批量更新
- react不能管控的地方（setInterval, setTimeout，原生的dom事件），就是非批量（遇到一次执行一次）的；

18. 在类组件中定义方法时，用 fn() => {}; 使用箭头函数的方式，this永远指向实例

19. ref
- 原生dom-ref：原生dom的ref本质上是dom，使用ref.current可以直接获取到dom，给ref赋值相当于直接修改dom的值;初始化的时候，在createDOM阶将真实dom的实例赋值给ref的current属性
- class-component-ref: 类组件的的ref的current组件指向的是类组件的实例；同样在渲染阶段将classInstance赋值给了ref的current；
- 函数组件-ref：不能给函数组件添加ref, 如果想要给函数组件添加ref，就必须用类组件再包装一层；forwardRef的原理

